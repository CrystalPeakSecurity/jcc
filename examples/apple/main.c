#include "jcc.h"
#include "jcc_fb.h" // Must be first - framebuffer at offset 0 for apduSendBytesLong
#include "video.h" // Compressed frame data (generated by encode.py)

#define INS_FRAME 0x01
#define INS_RESET 0x02

short current_frame = 0;

// RLE format: 0x00-0x7F = literal run, 0x80-0xFF = repeat (N & 0x7F) + 3 times
// Delta frames XOR onto previous; 0x00 runs = no change (skip)
void decode_frame(short frame_idx) {
    short src;
    short end;
    short dst;
    short count;
    byte value;

    if (frame_idx >= TOTAL_FRAMES) {
        frame_idx = 0;
    }

    src = frame_offsets[frame_idx];
    end = frame_offsets[frame_idx + 1];
    dst = 0;

#if USE_DELTA_ENCODING
    if (frame_idx == 0) {
        while (src < end) {
            value = frame_data[src] & 0xFF;
            src = src + 1;

            if ((value & 0x80) == 0) {
                count = value;
                while (count > 0) {
                    framebuffer[dst] = frame_data[src];
                    src = src + 1;
                    dst = dst + 1;
                    count = count - 1;
                }
            } else {
                count = (value & 0x7F) + 3;
                value = frame_data[src];
                src = src + 1;
                memset_at(framebuffer, dst, value, count);
                dst = dst + count;
            }
        }
    } else {
        while (src < end) {
            value = frame_data[src] & 0xFF;
            src = src + 1;

            if ((value & 0x80) == 0) {
                count = value;
                while (count > 0) {
                    framebuffer[dst] =
                        (framebuffer[dst] & 0xFF) ^ (frame_data[src] & 0xFF);
                    src = src + 1;
                    dst = dst + 1;
                    count = count - 1;
                }
            } else {
                count = (value & 0x7F) + 3;
                value = frame_data[src] & 0xFF;
                src = src + 1;

                if (value == 0x00) {
                    dst = dst + count;
                } else {
                    while (count > 0) {
                        framebuffer[dst] =
                            (framebuffer[dst] & 0xFF) ^ (value & 0xFF);
                        dst = dst + 1;
                        count = count - 1;
                    }
                }
            }
        }
    }
#else
    while (src < end) {
        value = frame_data[src] & 0xFF;
        src = src + 1;

        if ((value & 0x80) == 0) {
            count = value;
            while (count > 0) {
                framebuffer[dst] = frame_data[src];
                src = src + 1;
                dst = dst + 1;
                count = count - 1;
            }
        } else {
            count = (value & 0x7F) + 3;
            value = frame_data[src];
            src = src + 1;
            memset_at(framebuffer, dst, value, count);
            dst = dst + count;
        }
    }
#endif
}

void process(APDU apdu, short apdu_len) {
    byte *buffer = apduGetBuffer(apdu);
    byte ins = buffer[1];

    if (ins == INS_RESET) {
        current_frame = 0;
        clearFB();
        APDU_SEND(apdu, 0);
        return;
    }

    if (ins == INS_FRAME) {
        decode_frame(current_frame);
        current_frame = current_frame + 1;
        if (current_frame >= TOTAL_FRAMES) {
            current_frame = 0;
        }

        apduSetOutgoing(apdu);
        apduSetOutgoingLength(apdu, FB_SIZE);
        apduSendBytesLong(apdu, framebuffer, 0, FB_SIZE);
        return;
    }

    throwError(0x6D00);
}

// Workaround for JCSL simulator bug
void _jcsl_fix1(void) {}
void _jcsl_fix2(void) {}
void _jcsl_fix3(void) {}
