#!/usr/bin/env python3
"""Generate stack probe main.c with test functions having explicit locals.

Usage:
    python generate.py                    # Default: generate 1-100
    python generate.py --quick            # Quick probe: 2^N-1 and 1.5*2^N-1 values
    python generate.py --range 80 120     # Linear probe: 80-120
    python generate.py --slots 7 15 31    # Specific slot counts
"""

import argparse
import sys
from pathlib import Path


def compute_quick_slots(max_value: int = 1024) -> list[int]:
    """Compute 2^N-1 and 1.5*2^N-1 slot counts for quick binary search."""
    slots = set()
    n = 1
    while True:
        # 2^N - 1: 1, 3, 7, 15, 31, 63, 127, 255, 511...
        val = (1 << n) - 1
        if val > max_value:
            break
        slots.add(val)

        # 1.5 * 2^N - 1 (rounded): ~2, 5, 11, 23, 47, 95, 191, 383...
        val_half = int(1.5 * (1 << n)) - 1
        if val_half <= max_value:
            slots.add(val_half)

        n += 1

    return sorted(slots)


HEADER_TEMPLATE = '''// Stack probe applet - discovers exact stack limits on JavaCard hardware
// AUTO-GENERATED by generate.py - do not edit manually
//
// INS 0x01: Test stack with exactly N slots
//   P1:P2 = number of local slots to allocate
//   Returns: SW=9000 if OK, SW=6F00 if stack overflow
//
// Generated with: {cmd}
// Slot counts: {slots_summary}

#include "jcc.h"

'''


def generate_test_func(n: int) -> str:
    """Generate a test function with exactly n short locals.

    Uses volatile to prevent the compiler from optimizing locals away.
    """
    locals_decl = "\n".join(f"    volatile short v{i} = {i};" for i in range(n))
    # Chain reads so compiler can't eliminate any variable
    return f'''short test_{n}(void) {{
{locals_decl}
    return v{n-1};
}}

'''


def generate_dispatch(slots: list[int]) -> str:
    """Generate the process function with switch dispatch."""
    cases = []
    for n in slots:
        cases.append(f"        case {n}: result = test_{n}(); break;")

    cases_str = "\n".join(cases)
    max_slot = max(slots)

    return f'''void process(APDU apdu, short len) {{
    byte* buffer = apduGetBuffer(apdu);
    short ins = buffer[APDU_INS];
    short slots = READ_SHORT(buffer, 2);  // P1:P2
    short result = 0;

    if (ins != 0x01) {{
        throwError(0x6D00);
        return;
    }}

    // Dispatch to the appropriate test function
    switch (slots) {{
{cases_str}
        default:
            throwError(0x6A86);  // Unsupported slot count
            return;
    }}

    // Return the result
    buffer[0] = (byte)(result >> 8);
    buffer[1] = (byte)result;
    APDU_SEND(apdu, 2);
}}
'''


def generate_main_c(slots: list[int], cmd: str) -> str:
    """Generate the complete main.c file."""
    slots = sorted(slots)

    # Summarize slots for header
    if len(slots) <= 10:
        slots_summary = ", ".join(str(s) for s in slots)
    else:
        slots_summary = f"{slots[0]}-{slots[-1]} ({len(slots)} functions)"

    output = HEADER_TEMPLATE.format(cmd=cmd, slots_summary=slots_summary)

    for n in slots:
        output += generate_test_func(n)

    output += generate_dispatch(slots)

    return output


def main():
    parser = argparse.ArgumentParser(description="Generate stack probe main.c")
    parser.add_argument("--quick", action="store_true",
                        help="Generate 2^N-1 and 1.5*2^N-1 values for quick probing")
    parser.add_argument("--range", type=int, nargs=2, metavar=("MIN", "MAX"),
                        help="Generate linear range of slot counts")
    parser.add_argument("--slots", type=int, nargs="+",
                        help="Generate specific slot counts")
    parser.add_argument("--max", type=int, default=512,
                        help="Maximum slot value for --quick mode (default: 512)")
    parser.add_argument("-o", "--output", default="main.c",
                        help="Output file (default: main.c)")

    args = parser.parse_args()
    cmd = " ".join(sys.argv)

    # Determine which slots to generate
    if args.quick:
        slots = compute_quick_slots(args.max)
    elif args.range:
        slots = list(range(args.range[0], args.range[1] + 1))
    elif args.slots:
        slots = args.slots
    else:
        # Default: 1-100
        slots = list(range(1, 101))

    if not slots:
        print("Error: no slots to generate", file=sys.stderr)
        sys.exit(1)

    content = generate_main_c(slots, cmd)

    with open(args.output, "w") as f:
        f.write(content)

    # Write manifest of available slots (for probe.py)
    output_dir = Path(args.output).parent
    manifest_path = output_dir / "slots.txt"
    manifest_path.write_text(" ".join(str(s) for s in slots) + "\n")

    print(f"Generated {args.output} with {len(slots)} test functions")
    print(f"  Slots: {slots[0]}-{slots[-1]}" if len(slots) > 1 else f"  Slots: {slots[0]}")
    if len(slots) <= 20:
        print(f"  Values: {', '.join(str(s) for s in slots)}")


if __name__ == "__main__":
    main()
